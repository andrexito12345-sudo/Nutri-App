// backend/src/migrate_sqlite_to_pg_local.js
require("dotenv").config();

const path = require("path");
const sqlite3 = require("sqlite3").verbose();
const { Pool } = require("pg");

const SQLITE_PATH =
    process.env.SQLITE_PATH || path.join(__dirname, "nutriapp.db");

// Usa PG_URL o DATABASE_URL (local)
const PG_URL = process.env.PG_URL || process.env.DATABASE_URL;

if (!PG_URL) {
    console.error("‚ùå Falta PG_URL o DATABASE_URL en variables de entorno.");
    console.error("   Ejemplo: postgresql://postgres:TU_PASS@localhost:5432/nutriapp_local");
    process.exit(1);
}

const isLocal =
    PG_URL.includes("localhost") || PG_URL.includes("127.0.0.1");

const pool = new Pool({
    connectionString: PG_URL,
    ssl: isLocal ? false : { rejectUnauthorized: false },
});

function qIdent(name) {
    // Quote para Postgres: "col"
    return `"${String(name).replace(/"/g, '""')}"`;
}

function sqliteTypeToPg(sqliteType) {
    const t = (sqliteType || "").toUpperCase();

    // Afinidad SQLite -> PG
    if (t.includes("INT")) return "INTEGER";
    if (t.includes("CHAR") || t.includes("CLOB") || t.includes("TEXT")) return "TEXT";
    if (t.includes("BLOB")) return "BYTEA";
    if (t.includes("REAL") || t.includes("FLOA") || t.includes("DOUB")) return "DOUBLE PRECISION";
    if (t.includes("NUM") || t.includes("DEC")) return "NUMERIC";

    // Default seguro
    return "TEXT";
}

function normalizeDefault(dflt) {
    if (dflt == null) return null;

    let v = String(dflt).trim();

    // Quita par√©ntesis externos simples: (algo) -> algo
    // (Esto evita defaults como "(datetime('now'))")
    if (v.startsWith("(") && v.endsWith(")")) {
        v = v.slice(1, -1).trim();
    }

    // SQLite -> Postgres: datetime('now', ...) NO existe en PG
    // En PG lo equivalente es now() o CURRENT_TIMESTAMP
    if (/^datetime\s*\(/i.test(v) || /datetime\s*\(/i.test(v)) {
        return "now()";
    }

    // SQLite CURRENT_TIMESTAMP -> PG
    if (/CURRENT_TIMESTAMP/i.test(v)) {
        return "now()";
    }

    // Opcional: si aparece strftime(...) (SQLite) lo convertimos a now()
    // (si luego te falla por tipo, lo ajustamos)
    if (/strftime\s*\(/i.test(v)) {
        return "now()";
    }

    return v;
}


function sqliteAll(db, sql, params = []) {
    return new Promise((resolve, reject) => {
        db.all(sql, params, (err, rows) => (err ? reject(err) : resolve(rows)));
    });
}

async function createTableFromPragma(table, cols) {
    // cols = PRAGMA table_info => { name, type, notnull, dflt_value, pk }
    const colDefs = cols.map((c) => {
        const colName = qIdent(c.name);
        const isPk = Number(c.pk) === 1;
        const pgType = sqliteTypeToPg(c.type);

        // Si es PK entero, lo hacemos identity (permite insertar valores existentes)
        if (isPk && pgType === "INTEGER") {
            return `${colName} INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY`;
        }

        const notNull = Number(c.notnull) === 1 ? " NOT NULL" : "";
        const def = normalizeDefault(c.dflt_value);
        const defSql = def != null ? ` DEFAULT ${def}` : "";

        // Si es PK pero no entero, lo marcamos PK igualmente
        const pkSql = isPk ? " PRIMARY KEY" : "";

        return `${colName} ${pgType}${notNull}${defSql}${pkSql}`;
    });

    const sql = `CREATE TABLE IF NOT EXISTS ${qIdent(table)} (\n  ${colDefs.join(",\n  ")}\n);`;
    await pool.query(sql);
}

function chunkArray(arr, size) {
    const out = [];
    for (let i = 0; i < arr.length; i += size) out.push(arr.slice(i, i + size));
    return out;
}

async function insertRows(table, rows) {
    if (!rows.length) return;

    const columns = Object.keys(rows[0]); // asume todas las filas con mismas columnas
    const colSql = columns.map(qIdent).join(", ");

    const batchSize = 300; // ajusta si quieres
    const batches = chunkArray(rows, batchSize);

    for (const batch of batches) {
        const values = [];
        const placeholders = [];

        batch.forEach((row, rIdx) => {
            const rowPlaceholders = [];
            columns.forEach((col, cIdx) => {
                values.push(row[col]);
                rowPlaceholders.push(`$${rIdx * columns.length + cIdx + 1}`);
            });
            placeholders.push(`(${rowPlaceholders.join(", ")})`);
        });

        const sql = `INSERT INTO ${qIdent(table)} (${colSql}) VALUES ${placeholders.join(", ")};`;
        await pool.query(sql, values);
    }
}

async function setIdentitySequences(table, cols) {
    // Intentar ajustar secuencia si hay PK integer identity
    const pkInt = cols.find((c) => Number(c.pk) === 1 && sqliteTypeToPg(c.type) === "INTEGER");
    if (!pkInt) return;

    const col = pkInt.name;

    try {
        const seqRes = await pool.query(
            `SELECT pg_get_serial_sequence($1, $2) AS seq`,
            [table, col]
        );
        const seq = seqRes.rows?.[0]?.seq;
        if (!seq) return;

        await pool.query(
            `SELECT setval($1, COALESCE((SELECT MAX(${qIdent(col)}) FROM ${qIdent(table)}), 1), true);`,
            [seq]
        );
    } catch {
        // Si falla, no es cr√≠tico
    }
}

async function main() {
    console.log("‚úÖ Conectando a SQLite:", SQLITE_PATH);
    console.log("‚úÖ Conectando a Postgres:", isLocal ? "(local)" : "(remoto)");

    const sqliteDb = new sqlite3.Database(SQLITE_PATH);

    try {
        // 1) listar tablas
        const tables = await sqliteAll(
            sqliteDb,
            `SELECT name FROM sqlite_master
       WHERE type='table' AND name NOT LIKE 'sqlite_%'
       ORDER BY name;`
        );

        console.log("üì¶ Tablas encontradas en SQLite:", tables.map((t) => t.name).join(", "));

        // 2) crear tablas y copiar datos
        for (const { name: table } of tables) {
            console.log("\n‚û°Ô∏è Migrando tabla:", table);

            const cols = await sqliteAll(sqliteDb, `PRAGMA table_info("${table.replace(/"/g, '""')}");`);
            await createTableFromPragma(table, cols);

            const rows = await sqliteAll(sqliteDb, `SELECT * FROM "${table.replace(/"/g, '""')}";`);
            console.log(`   Filas en SQLite: ${rows.length}`);

            await insertRows(table, rows);
            await setIdentitySequences(table, cols);

            console.log("   ‚úÖ OK:", table);
        }

        console.log("\nüéâ Migraci√≥n completa.");
    } catch (err) {
        console.error("\n‚ùå Error en migraci√≥n:", err);
        process.exitCode = 1;
    } finally {
        sqliteDb.close();
        await pool.end();
    }
}

main();
